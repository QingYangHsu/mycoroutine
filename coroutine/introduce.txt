1。对称协程与非对称协程：
    两者的本质区别在于协程yield时可以将cpu控制权给谁，对称协程可以给任何人，非对称协程只能改调用者。sylar的项目是一个非对称协程

2。有栈协程与无栈协程：
    这里的栈指的是运行栈，运行栈上保存各种寄存器信息。有栈协程用独立的执行栈保存协程的上下文信息，
    无栈协程不需要独⽴的执⾏栈来保存协程的上下⽂信息，协程的上下⽂都放到公共内存中，
    当协程被挂起时，⽆栈协程会将协程的状态保存在堆上的数据结构中，并将控制权交还给调度器。
    当协程被恢复时，⽆栈协程会将之前保存的状态从堆中取出，并从上次挂起的地⽅继续执⾏。
    我们分别实现了有栈协程(和微信的libco库很像)与无栈协程(基于ucontext族函数)。

3。独立栈与共享栈(两者都是有栈协程？我对这里存疑？其实我认为正好和上面的有栈与无栈对应)：
    共享栈本质就是所有的协程在运⾏的时候都使⽤同⼀个栈空间，每次协程切换时要把⾃身⽤的共享栈空间拷⻉。
    对协程调⽤ yield 的时候，该协程栈内容暂时保存起来，保存的时候需要⽤到多少内存就开辟多少，这样就减少了内存的浪费， 
    resume 该协程的时候，协程之前保存的栈内容，会被重新拷⻉到运⾏时栈中。
    独⽴栈，也就是每个协程的栈空间都是独⽴的，固定⼤⼩。好处是协程切换的时候，内存不⽤拷⻉来拷⻉去。
    坏处则是 内存空间浪费。因为栈空间在运⾏时不能随时扩容，否则如果有指针操作执⾏了栈内存，扩容后将导致指针失效。为了防⽌栈内存不够，每个协程都要预先开⼀个⾜够的栈空间使⽤。
    当然很多协程在实际运⾏中也⽤不了这么⼤的空间，就必然造成内存的浪费和开辟⼤内存造成的性能损耗。
    我们的stack_co就是一个独立栈 stack_coless就是一个共享栈

4.协程优缺点：
    使用异步思想写出同步程序，但本质上仍是串行，无法利用多核资源。

5.协程对 CPU/IO 的影响
    协程的目的在于剔除线程的阻塞，尽可能提高 CPU 的利用率；
    很多服务在处理业务时需要请求第三方服务，向第三方服务发起 RPC 调用；RPC 调用的网络耗时一般耗时在毫秒级别，RPC 服务的处理耗时也可能在毫秒级别，如果当前服务使用同步调用，即 RPC 返回后才进行后续逻辑，那么一条线程每秒处理的业务数量是可以估算的；
    假设每次业务处理花费在 RPC 调用上的耗时是 20ms，那么一条线程一秒最多处理 50 次请求！
    如果在等待 RPC 返回时当前线程没有被系统调度转换为 Ready 状态，那当前 CPU 核心就会空转，浪费了 CPU 资源！通过增加线程数量提高系统吞吐量的效果非常有限，而且创建大量线程也会造成其他问题！
    协程虽然不一定能减少一次业务请求的耗时，但一定可以提升系统的吞吐量：
    当前业务只有一次第三方 RPC 的调用，那么协程不会减少业务处理的耗时，但可以提升 QPS；
    当前业务需要多个第三方 RPC 调用，同时创建多个协程可以让多个 RPC 调用一起执行，则当前业务的 RPC 耗时由耗时最长的 RPC 调用决定；

6.微信的libco库内部原理：
    微信的libco库就是一个有栈协程，其内部实现协程a向协程b的跳转时，将之前 cpu 寄存器的值保存到了协程A 的 regs[14] 中，而将协程B regs[14] 的内容写入到了寄存器中，从而使执行逻辑跳转到了 B 协程 regs[14] 中保存的返回地址处开始执行，即实现了协程的切换（从A 协程切换到了B协程执行），这也是void coctx_swap( coctx_t *,coctx_t* )这一函数调用的内部实现细节。


整体上看来，协程的切换其实就是： cpu 寄存器内容特别是 %rip 和 %rsp 的写入和恢复，
因为 cpu 的寄存器决定了程序从哪里执行（%rip) 和使用哪个地址作为堆栈 （%rsp）